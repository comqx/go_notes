[toc]

# 指针类型

>这里强调一下：
>`指针变量`是一个变量，这个变量的值是`指针`（内存地址）！
>`指针变量`是一个变量，这个变量的值是`指针`（内存地址）！
>`指针变量`是一个变量，这个变量的值是`指针`（内存地址）！



1. 普通类型，变量存的就是值，也叫值类型
2. 获取变量的地址，用&，比如：var a int，获取a的地址：&a
3. 指针类型，变量存的是一个地址，这个地址存的才是一个值
4. 获取指针类型所指向的值，使用：*，比如：var *p int,使用*p获取p指向的值

```go
	// &: 取地址
	n := 18
	p := &n
	fmt.Printf("%v,%T\n", p, p)   //0xc000098000,*int
	fmt.Printf("%v,%T\n", &n, &n) //0xc000098000,*int
	// *: 根据地址取值
	fmt.Printf("%v,%p\n", *p, &p) //18,0xc000088018

	a := 10
	b := &a
	fmt.Printf("a:%d ptr:%p\n", a, &a) // a:10 ptr:0xc00001a078
	fmt.Printf("b:%p type:%T\n", b, b) // b:0xc00001a078 type:*int
	fmt.Println(&b)                    // 0xc00000e018
```

![image-20190707223913471](../images/image-20190707223913471.png)

![image-20190721222300582](../images/image-20190721222300582.png)

# make和new的区别

1. make和new都是用来申请内存的
2. new很少用，一般用来给基本数据类型申请内存，`string`、`int`,返回的是对应类型的指针(\*string、\*int)。
3. make是用来给`slice`、`map`、`chan`申请内存的，make函数返回的的是对应的这三个类型本身

```go
	var a1 *int     //定义一个空指针
	fmt.Println(a1) //<nil>

	var a2 = new(int) //new函数申请一个内存地址
	fmt.Println(a2)   //0xc000096008
	fmt.Println(*a2) 
	*a2 = 100 //对地址赋值
	fmt.Println(*a2)
```



# 什么情况下面使用指针

- 不要对 map、slice、channel 这类引用类型使用指针；
- 如果需要修改方法接收者内部的数据或者状态时，需要使用指针；
- 如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数；
- 如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针；
- 像 int、bool 这样的小数据类型没必要使用指针；
- 如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；
- 指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。

